# App Plan: Math Problem Visualizer

## 1. Core Idea
An application that takes a math problem (specifically geometry or analytic geometry) as input, either via text or an image, and generates a visual representation of the problem.

## 2. Target Audience
Students who need to visualize math problems, particularly those in geometry and analytic geometry where diagrams are often not provided.

## 3. Input Mechanisms
*   **Image Input:**
    *   Users can upload or capture a photo of the math problem.
    *   The application will utilize an external image-to-text API.
    *   This API should support multiple languages for broader accessibility.
*   **Text Input:**
    *   Users can directly type or paste the text of the math problem into the application.

## 4. Processing Engine
*   **Text Extraction:** For image inputs, the chosen image-to-text API will convert the image into a machine-readable text string.
*   **Interpretation and Visualization Logic:**
    *   The extracted text (or directly input text) will be processed by the Google Gemini API.
    *   The application will send the problem text to the Gemini API along with a carefully crafted prompt or set of rules. These rules will instruct Gemini on how to:
        *   Identify key geometric/analytic entities (e.g., points, lines, shapes, angles, coordinates).
        *   Understand the relationships and constraints between these entities.
        *   Generate a structured description or a set of instructions that can be used to render the visualization.

## 5. Output
*   The application will display a visual image or diagram that accurately represents the information contained in the math problem.
*   (Further details on the nature of the visualization - e.g., static 2D, interactive, specific rendering style - can be defined later).

## 6. Potential Future Considerations (To be discussed)
*   Specific types of geometry/analytic geometry problems to prioritize.
*   Interactivity of the visualizations.
*   Choice of graphics library/engine for rendering.
*   Error handling for ambiguous problems or OCR inaccuracies.
*   User accounts or history of visualized problems.

## 7. Technical Specifications (Updated)

*   **Platform:** Web Application
    *   **Priority:** Mobile-friendly design and experience will be prioritized.
    *   **File/Camera Access:** Utilizes standard browser APIs (`<input type="file">`, `getUserMedia()`) requiring standard user permissions.
*   **Frontend Framework/Library:**
    *   **Core:** React
    *   **Framework:** Next.js
*   **UI Components & Design:** `shadcn/ui` will be used for building the user interface components and ensuring a consistent design.
*   **Backend:**
    *   Next.js API routes will be used for backend logic.
    *   A secure, isolated environment will be required for executing Python code generated by the Gemini API.
*   **Database & Storage:**
    *   **Supabase:** Will be used for:
        *   Storing generated images/visualizations to support shareable links.
        *   Potentially storing problem data associated with visualizations.
        *   (Future: User accounts, history).
*   **Visualization Generation:**
    *   The Google Gemini API will be prompted to generate Python code.
    *   This Python code will use:
        *   `Matplotlib` for plotting, especially for analytic geometry.
        *   `SymPy` (with `Matplotlib` for rendering) for defining and visualizing general geometric shapes and relationships.
    *   The backend will execute this Python code to produce an image (e.g., PNG), which will then be stored in Supabase Storage.
*   **Key APIs (External):**
    *   **Image-to-Text:** An external OCR API with multi-language support (specific API to be chosen).
    *   **Problem Interpretation & Code Generation:** Google Gemini API.

## 8. Minimum Viable Product (MVP) Features (Updated)

*   **Input & Correction:**
    1.  **Image Upload:** Users can upload image files (e.g., .jpg, .png) of math problems from their device (phone or computer) using the standard browser file input.
    2.  **In-App Image Capture:** Users can use their device's camera through the web app (via `getUserMedia()` API) to take a photo of a math problem directly, after granting permission.
    3.  **OCR Text Review & Edit:** After image input and OCR processing, the extracted text is displayed in a text box. The user can review, edit, and correct this text before submitting it for visualization.
    4.  **Direct Text Input:** Users can directly type or paste the text of the math problem into a text box.
*   **Processing & Error Handling:**
    *   The app sends the (user-verified) text to the Gemini API with appropriate prompting, instructing it to:
        *   Generate Python code (using Matplotlib/SymPy) for visualization.
        *   Output a specific error code or descriptive text if the input problem is unclear or cannot be processed, detailing what information is missing or ambiguous.
    *   The backend securely executes the generated Python code. If successful, the resulting image is saved (e.g., to Supabase Storage).
    *   The app provides clear feedback to the user:
        *   Displays the generated visualization if successful.
        *   Displays the specific error message/code from Gemini if the problem was unclear, guiding the user on how to refine their input.
        *   Handles and informs the user about technical errors during Python execution or OCR processing.
*   **Output & Sharing:**
    1.  **Display Visualization:** The generated image/diagram (retrieved from Supabase Storage or directly from the backend execution) is displayed clearly to the user.
    2.  **PNG Download:** Users can download the generated visualization as a PNG file.
    3.  **Copiable Link:** Users can get a shareable URL (pointing to a page that retrieves and displays the visualization from Supabase) that, when visited, displays the visualization.

## 9. Example User Flow: Visualizing a Question

This flow describes the step-by-step experience for a user from entering the app to getting their math problem visualized.

1.  **Entry & Input Selection:**
    *   The user opens the web application.
    *   The main interface presents clear options for input:
        *   A button to "Upload from device" (for image files).
        *   A button to "Take picture" (to use the device camera).
        *   A visible text box for typing or pasting the question directly.

2.  **Action based on Input Choice:**
    *   **If "Upload from device" is chosen:** The user is prompted by the browser to select an image file from their local storage/gallery. They select the file.
    *   **If "Take picture" is chosen:** The browser requests camera permission (if not already granted). The user takes a photo of the math problem using their device's camera interface.
    *   **If typing/pasting:** The user types or pastes the math problem directly into the provided text box.

3.  **Text Verification (for Image Inputs):**
    *   **If an image was uploaded or a picture was taken:**
        *   The image is sent to the selected OCR API.
        *   Once the OCR API returns the extracted text, this text populates a *new, editable text box* displayed prominently to the user.
        *   The user can review the recognized text in this box and make any necessary corrections or edits to ensure accuracy.

4.  **Submission:**
    *   Once the user is satisfied with the text (either directly entered or OCR-extracted and verified), they click a "Visualize" or "Send" button.

5.  **Processing & Display:**
    *   The application sends the finalized problem text to the backend.
    *   The backend processes the text with the Gemini API, executes the generated Python code (Matplotlib/SymPy), and stores the resulting image (e.g., in Supabase).
    *   The web application displays a loading indicator during this processing.
    *   Once ready, the generated visualization (image) of the math problem is displayed clearly to the user.

6.  **Sharing:**
    *   Alongside or below the displayed visualization, the user has access to sharing options:
        *   A button to "Download PNG" of the visualization.
        *   A button to "Copy Shareable Link" to the clipboard.
        *   (Potentially other sharing options in the future).

7.  **Error Handling (Implicit throughout):**
    *   If OCR fails, a message is shown.
    *   If Gemini API signals an unclear problem, the specific feedback is shown, likely with the text input area still active for correction.
    *   If there's a technical error during visualization generation, a user-friendly error message is displayed.
